#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>

#include "leveldb/db.h"
#include "leveldb/options.h"
#include "leveldb/status.h"
#include "leveldb/write_batch.h"

// Function to parse a line from the workload file
// Expected format:
// I <key> <value>  (Insert)
// D <key>          (Delete)
// Lines starting with '#' are comments and will be skipped.
bool ParseLine(const std::string& line, char& op_type, std::string& key, std::string& value) {
    if (line.empty() || line[0] == '#') {
        return false; // Skip comments or empty lines
    }

    std::istringstream iss(line);
    iss >> op_type;

    if (iss.fail()) {
        std::cerr << "Error: Could not parse operation type from line: \"" << line << "\"" << std::endl;
        return false;
    }

    if (op_type != 'I' && op_type != 'D') {
        std::cerr << "Error: Invalid operation type '" << op_type << "' in line: \"" << line << "\"" << std::endl;
        return false;
    }

    iss >> key;
    if (iss.fail() || key.empty()) {
        std::cerr << "Error: Could not parse key or key is empty from line: \"" << line << "\"" << std::endl;
        return false;
    }

    if (op_type == 'I') {
        // For insert operations, read the rest of the line as value.
        // This assumes the value generated by your Python script does not contain internal spaces
        // that are part of the value itself, but is a single token after the key.
        iss >> value;
        if (iss.fail()) { // Check if value was actually read
            std::cerr << "Error: Could not parse value for Insert operation in line: \"" << line << "\"" << std::endl;
            return false;
        }
        // If value could potentially contain spaces and you want to capture everything after the key:
        // std::string remaining_part;
        // std::getline(iss, remaining_part); // Read the rest of the line
        // if (!remaining_part.empty() && remaining_part[0] == ' ') { // Remove leading space if any
        //     value = remaining_part.substr(1);
        // } else {
        //     value = remaining_part; // Should not happen if format is "I key value"
        // }
        // if (value.empty() && op_type == 'I') {
        //    std::cerr << "Error: Value is empty for Insert operation in line: \"" << line << "\"" << std::endl;
        //    return false;
        // }
    }
    return true;
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <database_path> <workload_file_path>" << std::endl;
        return 1;
    }

    std::string db_path = argv[1];
    std::string workload_file_path = argv[2];

    leveldb::DB* db;
    leveldb::Options options;
    options.create_if_missing = true; // Create the database if it doesn't exist

    leveldb::Status status = leveldb::DB::Open(options, db_path, &db);  // 将impl类型的指针赋值给db
    if (!status.ok()) {
        std::cerr << "Error opening database " << db_path << ": " << status.ToString() << std::endl;
        return 1;
    }
    std::cout << "Database opened successfully: " << db_path << std::endl;

    std::ifstream workload_file(workload_file_path);
    if (!workload_file.is_open()) {
        std::cerr << "Error opening workload file: " << workload_file_path << std::endl;
        delete db;
        return 1;
    }
    std::cout << "Processing workload file: " << workload_file_path << std::endl;

    std::string line;
    char op_type;
    std::string key;
    std::string value;
    long long line_number = 0;
    long long operations_processed = 0;
    long long insert_count = 0;
    long long delete_count = 0;

    while (std::getline(workload_file, line)) {
        line_number++;
        if (ParseLine(line, op_type, key, value)) {
            operations_processed++;
            if (op_type == 'I') {
                status = db->Put(leveldb::WriteOptions(), key, value);
                if (status.ok()) {
                    insert_count++;
                    // std::cout << "Inserted: " << key << " -> " << value.substr(0, 20) << "..." << std::endl;
                } else {
                    std::cerr << "Line " << line_number << ": Put failed for key '" << key << "': " << status.ToString() << std::endl;
                }
            } else if (op_type == 'D') {
                status = db->Delete(leveldb::WriteOptions(), key);
                if (status.ok()) {
                    delete_count++;
                    // std::cout << "Deleted: " << key << std::endl;
                } else {
                    std::cerr << "Line " << line_number << ": Delete failed for key '" << key << "': " << status.ToString() << std::endl;
                }
            }
            if (operations_processed % 10000 == 0) {
                std::cout << "Processed " << operations_processed << " operations ("
                          << insert_count << " inserts, " << delete_count << " deletes)..." << std::endl;
            }
        } else {
            if (!line.empty() && line[0] != '#') {
                 std::cerr << "Skipping malformed or invalid line " << line_number << ": \"" << line << "\"" << std::endl;
            }
        }
    }

    std::cout << "Finished processing workload file." << std::endl;
    std::cout << "Total lines read: " << line_number << std::endl;
    std::cout << "Total valid operations processed: " << operations_processed << std::endl;
    std::cout << "Total inserts: " << insert_count << std::endl;
    std::cout << "Total deletes: " << delete_count << std::endl;

    workload_file.close();
    delete db; // Close the database

    std::cout << "Database closed." << std::endl;

    return 0;
}